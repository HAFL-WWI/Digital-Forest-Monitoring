{"id":"../node_modules/ol/interaction/Draw.js","dependencies":[{"name":"/Users/hk/Sites/digital-forest-monitoring/package.json","includedInParent":true,"mtime":1574333047455},{"name":"/Users/hk/Sites/digital-forest-monitoring/node_modules/ol/package.json","includedInParent":true,"mtime":1573122283680},{"name":"../events/EventType.js","loc":{"line":17,"column":22},"parent":"/Users/hk/Sites/digital-forest-monitoring/node_modules/ol/interaction/Draw.js","resolved":"/Users/hk/Sites/digital-forest-monitoring/node_modules/ol/events/EventType.js"},{"name":"../Feature.js","loc":{"line":18,"column":20},"parent":"/Users/hk/Sites/digital-forest-monitoring/node_modules/ol/interaction/Draw.js","resolved":"/Users/hk/Sites/digital-forest-monitoring/node_modules/ol/Feature.js"},{"name":"../MapBrowserEventType.js","loc":{"line":19,"column":32},"parent":"/Users/hk/Sites/digital-forest-monitoring/node_modules/ol/interaction/Draw.js","resolved":"/Users/hk/Sites/digital-forest-monitoring/node_modules/ol/MapBrowserEventType.js"},{"name":"../MapBrowserPointerEvent.js","loc":{"line":20,"column":35},"parent":"/Users/hk/Sites/digital-forest-monitoring/node_modules/ol/interaction/Draw.js","resolved":"/Users/hk/Sites/digital-forest-monitoring/node_modules/ol/MapBrowserPointerEvent.js"},{"name":"../Object.js","loc":{"line":21,"column":35},"parent":"/Users/hk/Sites/digital-forest-monitoring/node_modules/ol/interaction/Draw.js","resolved":"/Users/hk/Sites/digital-forest-monitoring/node_modules/ol/Object.js"},{"name":"../coordinate.js","loc":{"line":22,"column":61},"parent":"/Users/hk/Sites/digital-forest-monitoring/node_modules/ol/interaction/Draw.js","resolved":"/Users/hk/Sites/digital-forest-monitoring/node_modules/ol/coordinate.js"},{"name":"../events/Event.js","loc":{"line":23,"column":18},"parent":"/Users/hk/Sites/digital-forest-monitoring/node_modules/ol/interaction/Draw.js","resolved":"/Users/hk/Sites/digital-forest-monitoring/node_modules/ol/events/Event.js"},{"name":"../events/condition.js","loc":{"line":24,"column":53},"parent":"/Users/hk/Sites/digital-forest-monitoring/node_modules/ol/interaction/Draw.js","resolved":"/Users/hk/Sites/digital-forest-monitoring/node_modules/ol/events/condition.js"},{"name":"../extent.js","loc":{"line":25,"column":87},"parent":"/Users/hk/Sites/digital-forest-monitoring/node_modules/ol/interaction/Draw.js","resolved":"/Users/hk/Sites/digital-forest-monitoring/node_modules/ol/extent.js"},{"name":"../functions.js","loc":{"line":26,"column":28},"parent":"/Users/hk/Sites/digital-forest-monitoring/node_modules/ol/interaction/Draw.js","resolved":"/Users/hk/Sites/digital-forest-monitoring/node_modules/ol/functions.js"},{"name":"../geom/Circle.js","loc":{"line":27,"column":19},"parent":"/Users/hk/Sites/digital-forest-monitoring/node_modules/ol/interaction/Draw.js","resolved":"/Users/hk/Sites/digital-forest-monitoring/node_modules/ol/geom/Circle.js"},{"name":"../geom/GeometryType.js","loc":{"line":28,"column":25},"parent":"/Users/hk/Sites/digital-forest-monitoring/node_modules/ol/interaction/Draw.js","resolved":"/Users/hk/Sites/digital-forest-monitoring/node_modules/ol/geom/GeometryType.js"},{"name":"../geom/LineString.js","loc":{"line":29,"column":23},"parent":"/Users/hk/Sites/digital-forest-monitoring/node_modules/ol/interaction/Draw.js","resolved":"/Users/hk/Sites/digital-forest-monitoring/node_modules/ol/geom/LineString.js"},{"name":"../geom/MultiLineString.js","loc":{"line":30,"column":28},"parent":"/Users/hk/Sites/digital-forest-monitoring/node_modules/ol/interaction/Draw.js","resolved":"/Users/hk/Sites/digital-forest-monitoring/node_modules/ol/geom/MultiLineString.js"},{"name":"../geom/MultiPoint.js","loc":{"line":31,"column":23},"parent":"/Users/hk/Sites/digital-forest-monitoring/node_modules/ol/interaction/Draw.js","resolved":"/Users/hk/Sites/digital-forest-monitoring/node_modules/ol/geom/MultiPoint.js"},{"name":"../geom/MultiPolygon.js","loc":{"line":32,"column":25},"parent":"/Users/hk/Sites/digital-forest-monitoring/node_modules/ol/interaction/Draw.js","resolved":"/Users/hk/Sites/digital-forest-monitoring/node_modules/ol/geom/MultiPolygon.js"},{"name":"../geom/Point.js","loc":{"line":33,"column":18},"parent":"/Users/hk/Sites/digital-forest-monitoring/node_modules/ol/interaction/Draw.js","resolved":"/Users/hk/Sites/digital-forest-monitoring/node_modules/ol/geom/Point.js"},{"name":"../geom/Polygon.js","loc":{"line":34,"column":49},"parent":"/Users/hk/Sites/digital-forest-monitoring/node_modules/ol/interaction/Draw.js","resolved":"/Users/hk/Sites/digital-forest-monitoring/node_modules/ol/geom/Polygon.js"},{"name":"./Pointer.js","loc":{"line":35,"column":31},"parent":"/Users/hk/Sites/digital-forest-monitoring/node_modules/ol/interaction/Draw.js","resolved":"/Users/hk/Sites/digital-forest-monitoring/node_modules/ol/interaction/Pointer.js"},{"name":"./Property.js","loc":{"line":36,"column":32},"parent":"/Users/hk/Sites/digital-forest-monitoring/node_modules/ol/interaction/Draw.js","resolved":"/Users/hk/Sites/digital-forest-monitoring/node_modules/ol/interaction/Property.js"},{"name":"../layer/Vector.js","loc":{"line":37,"column":24},"parent":"/Users/hk/Sites/digital-forest-monitoring/node_modules/ol/interaction/Draw.js","resolved":"/Users/hk/Sites/digital-forest-monitoring/node_modules/ol/layer/Vector.js"},{"name":"../source/Vector.js","loc":{"line":38,"column":25},"parent":"/Users/hk/Sites/digital-forest-monitoring/node_modules/ol/interaction/Draw.js","resolved":"/Users/hk/Sites/digital-forest-monitoring/node_modules/ol/source/Vector.js"},{"name":"../style/Style.js","loc":{"line":39,"column":35},"parent":"/Users/hk/Sites/digital-forest-monitoring/node_modules/ol/interaction/Draw.js","resolved":"/Users/hk/Sites/digital-forest-monitoring/node_modules/ol/style/Style.js"}],"generated":{"js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createRegularPolygon = createRegularPolygon;\nexports.createBox = createBox;\nexports.default = void 0;\n\nvar _EventType = _interopRequireDefault(require(\"../events/EventType.js\"));\n\nvar _Feature = _interopRequireDefault(require(\"../Feature.js\"));\n\nvar _MapBrowserEventType = _interopRequireDefault(require(\"../MapBrowserEventType.js\"));\n\nvar _MapBrowserPointerEvent = _interopRequireDefault(require(\"../MapBrowserPointerEvent.js\"));\n\nvar _Object = require(\"../Object.js\");\n\nvar _coordinate = require(\"../coordinate.js\");\n\nvar _Event = _interopRequireDefault(require(\"../events/Event.js\"));\n\nvar _condition = require(\"../events/condition.js\");\n\nvar _extent = require(\"../extent.js\");\n\nvar _functions = require(\"../functions.js\");\n\nvar _Circle = _interopRequireDefault(require(\"../geom/Circle.js\"));\n\nvar _GeometryType = _interopRequireDefault(require(\"../geom/GeometryType.js\"));\n\nvar _LineString = _interopRequireDefault(require(\"../geom/LineString.js\"));\n\nvar _MultiLineString = _interopRequireDefault(require(\"../geom/MultiLineString.js\"));\n\nvar _MultiPoint = _interopRequireDefault(require(\"../geom/MultiPoint.js\"));\n\nvar _MultiPolygon = _interopRequireDefault(require(\"../geom/MultiPolygon.js\"));\n\nvar _Point = _interopRequireDefault(require(\"../geom/Point.js\"));\n\nvar _Polygon = _interopRequireWildcard(require(\"../geom/Polygon.js\"));\n\nvar _Pointer = _interopRequireDefault(require(\"./Pointer.js\"));\n\nvar _Property = _interopRequireDefault(require(\"./Property.js\"));\n\nvar _Vector = _interopRequireDefault(require(\"../layer/Vector.js\"));\n\nvar _Vector2 = _interopRequireDefault(require(\"../source/Vector.js\"));\n\nvar _Style = require(\"../style/Style.js\");\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; if (obj != null) { var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar __extends = void 0 && (void 0).__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n/**\n * @module ol/interaction/Draw\n */\n\n\n/**\n * @typedef {Object} Options\n * @property {GeometryType} type Geometry type of\n * the geometries being drawn with this instance.\n * @property {number} [clickTolerance=6] The maximum distance in pixels between\n * \"down\" and \"up\" for a \"up\" event to be considered a \"click\" event and\n * actually add a point/vertex to the geometry being drawn.  The default of `6`\n * was chosen for the draw interaction to behave correctly on mouse as well as\n * on touch devices.\n * @property {import(\"../Collection.js\").default<Feature>} [features]\n * Destination collection for the drawn features.\n * @property {VectorSource} [source] Destination source for\n * the drawn features.\n * @property {number} [dragVertexDelay=500] Delay in milliseconds after pointerdown\n * before the current vertex can be dragged to its exact position.\n * @property {number} [snapTolerance=12] Pixel distance for snapping to the\n * drawing finish.\n * @property {boolean} [stopClick=false] Stop click, singleclick, and\n * doubleclick events from firing during drawing.\n * @property {number} [maxPoints] The number of points that can be drawn before\n * a polygon ring or line string is finished. By default there is no\n * restriction.\n * @property {number} [minPoints] The number of points that must be drawn\n * before a polygon ring or line string can be finished. Default is `3` for\n * polygon rings and `2` for line strings.\n * @property {import(\"../events/condition.js\").Condition} [finishCondition] A function\n * that takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a\n * boolean to indicate whether the drawing can be finished.\n * @property {import(\"../style/Style.js\").StyleLike} [style]\n * Style for sketch features.\n * @property {GeometryFunction} [geometryFunction]\n * Function that is called when a geometry's coordinates are updated.\n * @property {string} [geometryName] Geometry name to use for features created\n * by the draw interaction.\n * @property {import(\"../events/condition.js\").Condition} [condition] A function that\n * takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a\n * boolean to indicate whether that event should be handled.\n * By default {@link module:ol/events/condition~noModifierKeys}, i.e. a click,\n * adds a vertex or deactivates freehand drawing.\n * @property {boolean} [freehand=false] Operate in freehand mode for lines,\n * polygons, and circles.  This makes the interaction always operate in freehand\n * mode and takes precedence over any `freehandCondition` option.\n * @property {import(\"../events/condition.js\").Condition} [freehandCondition]\n * Condition that activates freehand drawing for lines and polygons. This\n * function takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and\n * returns a boolean to indicate whether that event should be handled. The\n * default is {@link module:ol/events/condition~shiftKeyOnly}, meaning that the\n * Shift key activates freehand drawing.\n * @property {boolean} [wrapX=false] Wrap the world horizontally on the sketch\n * overlay.\n */\n\n/**\n * Coordinate type when drawing points.\n * @typedef {import(\"../coordinate.js\").Coordinate} PointCoordType\n */\n\n/**\n * Coordinate type when drawing lines.\n * @typedef {Array<import(\"../coordinate.js\").Coordinate>} LineCoordType\n */\n\n/**\n * Coordinate type when drawing polygons.\n * @typedef {Array<Array<import(\"../coordinate.js\").Coordinate>>} PolyCoordType\n */\n\n/**\n * Types used for drawing coordinates.\n * @typedef {PointCoordType|LineCoordType|PolyCoordType} SketchCoordType\n */\n\n/**\n * Function that takes an array of coordinates and an optional existing geometry as\n * arguments, and returns a geometry. The optional existing geometry is the\n * geometry that is returned when the function is called without a second\n * argument.\n * @typedef {function(!SketchCoordType, import(\"../geom/SimpleGeometry.js\").default=):\n *     import(\"../geom/SimpleGeometry.js\").default} GeometryFunction\n */\n\n/**\n * Draw mode.  This collapses multi-part geometry types with their single-part\n * cousins.\n * @enum {string}\n */\nvar Mode = {\n  POINT: 'Point',\n  LINE_STRING: 'LineString',\n  POLYGON: 'Polygon',\n  CIRCLE: 'Circle'\n};\n/**\n * @enum {string}\n */\n\nvar DrawEventType = {\n  /**\n   * Triggered upon feature draw start\n   * @event DrawEvent#drawstart\n   * @api\n   */\n  DRAWSTART: 'drawstart',\n\n  /**\n   * Triggered upon feature draw end\n   * @event DrawEvent#drawend\n   * @api\n   */\n  DRAWEND: 'drawend'\n};\n/**\n * @classdesc\n * Events emitted by {@link module:ol/interaction/Draw~Draw} instances are\n * instances of this type.\n */\n\nvar DrawEvent =\n/** @class */\nfunction (_super) {\n  __extends(DrawEvent, _super);\n  /**\n   * @param {DrawEventType} type Type.\n   * @param {Feature} feature The feature drawn.\n   */\n\n\n  function DrawEvent(type, feature) {\n    var _this = _super.call(this, type) || this;\n    /**\n     * The feature being drawn.\n     * @type {Feature}\n     * @api\n     */\n\n\n    _this.feature = feature;\n    return _this;\n  }\n\n  return DrawEvent;\n}(_Event.default);\n/**\n * @classdesc\n * Interaction for drawing feature geometries.\n *\n * @fires DrawEvent\n * @api\n */\n\n\nvar Draw =\n/** @class */\nfunction (_super) {\n  __extends(Draw, _super);\n  /**\n   * @param {Options} options Options.\n   */\n\n\n  function Draw(options) {\n    var _this = this;\n\n    var pointerOptions =\n    /** @type {import(\"./Pointer.js\").Options} */\n    options;\n\n    if (!pointerOptions.stopDown) {\n      pointerOptions.stopDown = _functions.FALSE;\n    }\n\n    _this = _super.call(this, pointerOptions) || this;\n    /**\n     * @type {boolean}\n     * @private\n     */\n\n    _this.shouldHandle_ = false;\n    /**\n     * @type {import(\"../pixel.js\").Pixel}\n     * @private\n     */\n\n    _this.downPx_ = null;\n    /**\n     * @type {?}\n     * @private\n     */\n\n    _this.downTimeout_;\n    /**\n     * @type {number|undefined}\n     * @private\n     */\n\n    _this.lastDragTime_;\n    /**\n     * @type {boolean}\n     * @private\n     */\n\n    _this.freehand_ = false;\n    /**\n     * Target source for drawn features.\n     * @type {VectorSource}\n     * @private\n     */\n\n    _this.source_ = options.source ? options.source : null;\n    /**\n     * Target collection for drawn features.\n     * @type {import(\"../Collection.js\").default<Feature>}\n     * @private\n     */\n\n    _this.features_ = options.features ? options.features : null;\n    /**\n     * Pixel distance for snapping.\n     * @type {number}\n     * @private\n     */\n\n    _this.snapTolerance_ = options.snapTolerance ? options.snapTolerance : 12;\n    /**\n     * Geometry type.\n     * @type {GeometryType}\n     * @private\n     */\n\n    _this.type_ =\n    /** @type {GeometryType} */\n    options.type;\n    /**\n     * Drawing mode (derived from geometry type.\n     * @type {Mode}\n     * @private\n     */\n\n    _this.mode_ = getMode(_this.type_);\n    /**\n     * Stop click, singleclick, and doubleclick events from firing during drawing.\n     * Default is `false`.\n     * @type {boolean}\n     * @private\n     */\n\n    _this.stopClick_ = !!options.stopClick;\n    /**\n     * The number of points that must be drawn before a polygon ring or line\n     * string can be finished.  The default is 3 for polygon rings and 2 for\n     * line strings.\n     * @type {number}\n     * @private\n     */\n\n    _this.minPoints_ = options.minPoints ? options.minPoints : _this.mode_ === Mode.POLYGON ? 3 : 2;\n    /**\n     * The number of points that can be drawn before a polygon ring or line string\n     * is finished. The default is no restriction.\n     * @type {number}\n     * @private\n     */\n\n    _this.maxPoints_ = options.maxPoints ? options.maxPoints : Infinity;\n    /**\n     * A function to decide if a potential finish coordinate is permissible\n     * @private\n     * @type {import(\"../events/condition.js\").Condition}\n     */\n\n    _this.finishCondition_ = options.finishCondition ? options.finishCondition : _functions.TRUE;\n    var geometryFunction = options.geometryFunction;\n\n    if (!geometryFunction) {\n      if (_this.type_ === _GeometryType.default.CIRCLE) {\n        /**\n         * @param {!LineCoordType} coordinates The coordinates.\n         * @param {import(\"../geom/SimpleGeometry.js\").default=} opt_geometry Optional geometry.\n         * @return {import(\"../geom/SimpleGeometry.js\").default} A geometry.\n         */\n        geometryFunction = function (coordinates, opt_geometry) {\n          var circle = opt_geometry ?\n          /** @type {Circle} */\n          opt_geometry : new _Circle.default([NaN, NaN]);\n          var squaredLength = (0, _coordinate.squaredDistance)(coordinates[0], coordinates[1]);\n          circle.setCenterAndRadius(coordinates[0], Math.sqrt(squaredLength));\n          return circle;\n        };\n      } else {\n        var Constructor_1;\n        var mode_1 = _this.mode_;\n\n        if (mode_1 === Mode.POINT) {\n          Constructor_1 = _Point.default;\n        } else if (mode_1 === Mode.LINE_STRING) {\n          Constructor_1 = _LineString.default;\n        } else if (mode_1 === Mode.POLYGON) {\n          Constructor_1 = _Polygon.default;\n        }\n        /**\n         * @param {!LineCoordType} coordinates The coordinates.\n         * @param {import(\"../geom/SimpleGeometry.js\").default=} opt_geometry Optional geometry.\n         * @return {import(\"../geom/SimpleGeometry.js\").default} A geometry.\n         */\n\n\n        geometryFunction = function (coordinates, opt_geometry) {\n          var geometry = opt_geometry;\n\n          if (geometry) {\n            if (mode_1 === Mode.POLYGON) {\n              if (coordinates[0].length) {\n                // Add a closing coordinate to match the first\n                geometry.setCoordinates([coordinates[0].concat([coordinates[0][0]])]);\n              } else {\n                geometry.setCoordinates([]);\n              }\n            } else {\n              geometry.setCoordinates(coordinates);\n            }\n          } else {\n            geometry = new Constructor_1(coordinates);\n          }\n\n          return geometry;\n        };\n      }\n    }\n    /**\n     * @type {GeometryFunction}\n     * @private\n     */\n\n\n    _this.geometryFunction_ = geometryFunction;\n    /**\n     * @type {number}\n     * @private\n     */\n\n    _this.dragVertexDelay_ = options.dragVertexDelay !== undefined ? options.dragVertexDelay : 500;\n    /**\n     * Finish coordinate for the feature (first point for polygons, last point for\n     * linestrings).\n     * @type {import(\"../coordinate.js\").Coordinate}\n     * @private\n     */\n\n    _this.finishCoordinate_ = null;\n    /**\n     * Sketch feature.\n     * @type {Feature}\n     * @private\n     */\n\n    _this.sketchFeature_ = null;\n    /**\n     * Sketch point.\n     * @type {Feature<Point>}\n     * @private\n     */\n\n    _this.sketchPoint_ = null;\n    /**\n     * Sketch coordinates. Used when drawing a line or polygon.\n     * @type {SketchCoordType}\n     * @private\n     */\n\n    _this.sketchCoords_ = null;\n    /**\n     * Sketch line. Used when drawing polygon.\n     * @type {Feature<LineString>}\n     * @private\n     */\n\n    _this.sketchLine_ = null;\n    /**\n     * Sketch line coordinates. Used when drawing a polygon or circle.\n     * @type {LineCoordType}\n     * @private\n     */\n\n    _this.sketchLineCoords_ = null;\n    /**\n     * Squared tolerance for handling up events.  If the squared distance\n     * between a down and up event is greater than this tolerance, up events\n     * will not be handled.\n     * @type {number}\n     * @private\n     */\n\n    _this.squaredClickTolerance_ = options.clickTolerance ? options.clickTolerance * options.clickTolerance : 36;\n    /**\n     * Draw overlay where our sketch features are drawn.\n     * @type {VectorLayer}\n     * @private\n     */\n\n    _this.overlay_ = new _Vector.default({\n      source: new _Vector2.default({\n        useSpatialIndex: false,\n        wrapX: options.wrapX ? options.wrapX : false\n      }),\n      style: options.style ? options.style : getDefaultStyleFunction(),\n      updateWhileInteracting: true\n    });\n    /**\n     * Name of the geometry attribute for newly created features.\n     * @type {string|undefined}\n     * @private\n     */\n\n    _this.geometryName_ = options.geometryName;\n    /**\n     * @private\n     * @type {import(\"../events/condition.js\").Condition}\n     */\n\n    _this.condition_ = options.condition ? options.condition : _condition.noModifierKeys;\n    /**\n     * @private\n     * @type {import(\"../events/condition.js\").Condition}\n     */\n\n    _this.freehandCondition_;\n\n    if (options.freehand) {\n      _this.freehandCondition_ = _condition.always;\n    } else {\n      _this.freehandCondition_ = options.freehandCondition ? options.freehandCondition : _condition.shiftKeyOnly;\n    }\n\n    _this.addEventListener((0, _Object.getChangeEventType)(_Property.default.ACTIVE), _this.updateState_);\n\n    return _this;\n  }\n  /**\n   * @inheritDoc\n   */\n\n\n  Draw.prototype.setMap = function (map) {\n    _super.prototype.setMap.call(this, map);\n\n    this.updateState_();\n  };\n  /**\n   * Get the overlay layer that this interaction renders sketch features to.\n   * @return {VectorLayer} Overlay layer.\n   * @api\n   */\n\n\n  Draw.prototype.getOverlay = function () {\n    return this.overlay_;\n  };\n  /**\n   * Handles the {@link module:ol/MapBrowserEvent map browser event} and may actually draw or finish the drawing.\n   * @override\n   * @api\n   */\n\n\n  Draw.prototype.handleEvent = function (event) {\n    if (event.originalEvent.type === _EventType.default.CONTEXTMENU) {\n      // Avoid context menu for long taps when drawing on mobile\n      event.preventDefault();\n    }\n\n    this.freehand_ = this.mode_ !== Mode.POINT && this.freehandCondition_(event);\n    var move = event.type === _MapBrowserEventType.default.POINTERMOVE;\n    var pass = true;\n\n    if (!this.freehand_ && this.lastDragTime_ && event.type === _MapBrowserEventType.default.POINTERDRAG) {\n      var now = Date.now();\n\n      if (now - this.lastDragTime_ >= this.dragVertexDelay_) {\n        this.downPx_ = event.pixel;\n        this.shouldHandle_ = !this.freehand_;\n        move = true;\n      } else {\n        this.lastDragTime_ = undefined;\n      }\n\n      if (this.shouldHandle_ && this.downTimeout_ !== undefined) {\n        clearTimeout(this.downTimeout_);\n        this.downTimeout_ = undefined;\n      }\n    }\n\n    if (this.freehand_ && event.type === _MapBrowserEventType.default.POINTERDRAG && this.sketchFeature_ !== null) {\n      this.addToDrawing_(event);\n      pass = false;\n    } else if (this.freehand_ && event.type === _MapBrowserEventType.default.POINTERDOWN) {\n      pass = false;\n    } else if (move) {\n      pass = event.type === _MapBrowserEventType.default.POINTERMOVE;\n\n      if (pass && this.freehand_) {\n        pass = this.handlePointerMove_(event);\n      } else if (\n      /** @type {MapBrowserPointerEvent} */\n      event.pointerEvent.pointerType == 'mouse' || event.type === _MapBrowserEventType.default.POINTERDRAG && this.downTimeout_ === undefined) {\n        this.handlePointerMove_(event);\n      }\n    } else if (event.type === _MapBrowserEventType.default.DBLCLICK) {\n      pass = false;\n    }\n\n    return _super.prototype.handleEvent.call(this, event) && pass;\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  Draw.prototype.handleDownEvent = function (event) {\n    this.shouldHandle_ = !this.freehand_;\n\n    if (this.freehand_) {\n      this.downPx_ = event.pixel;\n\n      if (!this.finishCoordinate_) {\n        this.startDrawing_(event);\n      }\n\n      return true;\n    } else if (this.condition_(event)) {\n      this.lastDragTime_ = Date.now();\n      this.downTimeout_ = setTimeout(function () {\n        this.handlePointerMove_(new _MapBrowserPointerEvent.default(_MapBrowserEventType.default.POINTERMOVE, event.map, event.pointerEvent, false, event.frameState));\n      }.bind(this), this.dragVertexDelay_);\n      this.downPx_ = event.pixel;\n      return true;\n    } else {\n      this.lastDragTime_ = undefined;\n      return false;\n    }\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  Draw.prototype.handleUpEvent = function (event) {\n    var pass = true;\n\n    if (this.downTimeout_) {\n      clearTimeout(this.downTimeout_);\n      this.downTimeout_ = undefined;\n    }\n\n    this.handlePointerMove_(event);\n    var circleMode = this.mode_ === Mode.CIRCLE;\n\n    if (this.shouldHandle_) {\n      if (!this.finishCoordinate_) {\n        this.startDrawing_(event);\n\n        if (this.mode_ === Mode.POINT) {\n          this.finishDrawing();\n        }\n      } else if (this.freehand_ || circleMode) {\n        this.finishDrawing();\n      } else if (this.atFinish_(event)) {\n        if (this.finishCondition_(event)) {\n          this.finishDrawing();\n        }\n      } else {\n        this.addToDrawing_(event);\n      }\n\n      pass = false;\n    } else if (this.freehand_) {\n      this.finishCoordinate_ = null;\n      this.abortDrawing_();\n    }\n\n    if (!pass && this.stopClick_) {\n      event.stopPropagation();\n    }\n\n    return pass;\n  };\n  /**\n   * Handle move events.\n   * @param {import(\"../MapBrowserEvent.js\").default} event A move event.\n   * @return {boolean} Pass the event to other interactions.\n   * @private\n   */\n\n\n  Draw.prototype.handlePointerMove_ = function (event) {\n    if (this.downPx_ && (!this.freehand_ && this.shouldHandle_ || this.freehand_ && !this.shouldHandle_)) {\n      var downPx = this.downPx_;\n      var clickPx = event.pixel;\n      var dx = downPx[0] - clickPx[0];\n      var dy = downPx[1] - clickPx[1];\n      var squaredDistance = dx * dx + dy * dy;\n      this.shouldHandle_ = this.freehand_ ? squaredDistance > this.squaredClickTolerance_ : squaredDistance <= this.squaredClickTolerance_;\n\n      if (!this.shouldHandle_) {\n        return true;\n      }\n    }\n\n    if (this.finishCoordinate_) {\n      this.modifyDrawing_(event);\n    } else {\n      this.createOrUpdateSketchPoint_(event);\n    }\n\n    return true;\n  };\n  /**\n   * Determine if an event is within the snapping tolerance of the start coord.\n   * @param {import(\"../MapBrowserEvent.js\").default} event Event.\n   * @return {boolean} The event is within the snapping tolerance of the start.\n   * @private\n   */\n\n\n  Draw.prototype.atFinish_ = function (event) {\n    var at = false;\n\n    if (this.sketchFeature_) {\n      var potentiallyDone = false;\n      var potentiallyFinishCoordinates = [this.finishCoordinate_];\n\n      if (this.mode_ === Mode.LINE_STRING) {\n        potentiallyDone = this.sketchCoords_.length > this.minPoints_;\n      } else if (this.mode_ === Mode.POLYGON) {\n        var sketchCoords =\n        /** @type {PolyCoordType} */\n        this.sketchCoords_;\n        potentiallyDone = sketchCoords[0].length > this.minPoints_;\n        potentiallyFinishCoordinates = [sketchCoords[0][0], sketchCoords[0][sketchCoords[0].length - 2]];\n      }\n\n      if (potentiallyDone) {\n        var map = event.map;\n\n        for (var i = 0, ii = potentiallyFinishCoordinates.length; i < ii; i++) {\n          var finishCoordinate = potentiallyFinishCoordinates[i];\n          var finishPixel = map.getPixelFromCoordinate(finishCoordinate);\n          var pixel = event.pixel;\n          var dx = pixel[0] - finishPixel[0];\n          var dy = pixel[1] - finishPixel[1];\n          var snapTolerance = this.freehand_ ? 1 : this.snapTolerance_;\n          at = Math.sqrt(dx * dx + dy * dy) <= snapTolerance;\n\n          if (at) {\n            this.finishCoordinate_ = finishCoordinate;\n            break;\n          }\n        }\n      }\n    }\n\n    return at;\n  };\n  /**\n   * @param {import(\"../MapBrowserEvent.js\").default} event Event.\n   * @private\n   */\n\n\n  Draw.prototype.createOrUpdateSketchPoint_ = function (event) {\n    var coordinates = event.coordinate.slice();\n\n    if (!this.sketchPoint_) {\n      this.sketchPoint_ = new _Feature.default(new _Point.default(coordinates));\n      this.updateSketchFeatures_();\n    } else {\n      var sketchPointGeom = this.sketchPoint_.getGeometry();\n      sketchPointGeom.setCoordinates(coordinates);\n    }\n  };\n  /**\n   * Start the drawing.\n   * @param {import(\"../MapBrowserEvent.js\").default} event Event.\n   * @private\n   */\n\n\n  Draw.prototype.startDrawing_ = function (event) {\n    var start = event.coordinate;\n    this.finishCoordinate_ = start;\n\n    if (this.mode_ === Mode.POINT) {\n      this.sketchCoords_ = start.slice();\n    } else if (this.mode_ === Mode.POLYGON) {\n      this.sketchCoords_ = [[start.slice(), start.slice()]];\n      this.sketchLineCoords_ = this.sketchCoords_[0];\n    } else {\n      this.sketchCoords_ = [start.slice(), start.slice()];\n    }\n\n    if (this.sketchLineCoords_) {\n      this.sketchLine_ = new _Feature.default(new _LineString.default(this.sketchLineCoords_));\n    }\n\n    var geometry = this.geometryFunction_(this.sketchCoords_);\n    this.sketchFeature_ = new _Feature.default();\n\n    if (this.geometryName_) {\n      this.sketchFeature_.setGeometryName(this.geometryName_);\n    }\n\n    this.sketchFeature_.setGeometry(geometry);\n    this.updateSketchFeatures_();\n    this.dispatchEvent(new DrawEvent(DrawEventType.DRAWSTART, this.sketchFeature_));\n  };\n  /**\n   * Modify the drawing.\n   * @param {import(\"../MapBrowserEvent.js\").default} event Event.\n   * @private\n   */\n\n\n  Draw.prototype.modifyDrawing_ = function (event) {\n    var coordinate = event.coordinate;\n    var geometry = this.sketchFeature_.getGeometry();\n    var coordinates, last;\n\n    if (this.mode_ === Mode.POINT) {\n      last = this.sketchCoords_;\n    } else if (this.mode_ === Mode.POLYGON) {\n      coordinates =\n      /** @type {PolyCoordType} */\n      this.sketchCoords_[0];\n      last = coordinates[coordinates.length - 1];\n\n      if (this.atFinish_(event)) {\n        // snap to finish\n        coordinate = this.finishCoordinate_.slice();\n      }\n    } else {\n      coordinates = this.sketchCoords_;\n      last = coordinates[coordinates.length - 1];\n    }\n\n    last[0] = coordinate[0];\n    last[1] = coordinate[1];\n    this.geometryFunction_(\n    /** @type {!LineCoordType} */\n    this.sketchCoords_, geometry);\n\n    if (this.sketchPoint_) {\n      var sketchPointGeom = this.sketchPoint_.getGeometry();\n      sketchPointGeom.setCoordinates(coordinate);\n    }\n    /** @type {LineString} */\n\n\n    var sketchLineGeom;\n\n    if (geometry.getType() == _GeometryType.default.POLYGON && this.mode_ !== Mode.POLYGON) {\n      if (!this.sketchLine_) {\n        this.sketchLine_ = new _Feature.default();\n      }\n\n      var ring = geometry.getLinearRing(0);\n      sketchLineGeom = this.sketchLine_.getGeometry();\n\n      if (!sketchLineGeom) {\n        sketchLineGeom = new _LineString.default(ring.getFlatCoordinates(), ring.getLayout());\n        this.sketchLine_.setGeometry(sketchLineGeom);\n      } else {\n        sketchLineGeom.setFlatCoordinates(ring.getLayout(), ring.getFlatCoordinates());\n        sketchLineGeom.changed();\n      }\n    } else if (this.sketchLineCoords_) {\n      sketchLineGeom = this.sketchLine_.getGeometry();\n      sketchLineGeom.setCoordinates(this.sketchLineCoords_);\n    }\n\n    this.updateSketchFeatures_();\n  };\n  /**\n   * Add a new coordinate to the drawing.\n   * @param {import(\"../MapBrowserEvent.js\").default} event Event.\n   * @private\n   */\n\n\n  Draw.prototype.addToDrawing_ = function (event) {\n    var coordinate = event.coordinate;\n    var geometry = this.sketchFeature_.getGeometry();\n    var done;\n    var coordinates;\n\n    if (this.mode_ === Mode.LINE_STRING) {\n      this.finishCoordinate_ = coordinate.slice();\n      coordinates =\n      /** @type {LineCoordType} */\n      this.sketchCoords_;\n\n      if (coordinates.length >= this.maxPoints_) {\n        if (this.freehand_) {\n          coordinates.pop();\n        } else {\n          done = true;\n        }\n      }\n\n      coordinates.push(coordinate.slice());\n      this.geometryFunction_(coordinates, geometry);\n    } else if (this.mode_ === Mode.POLYGON) {\n      coordinates =\n      /** @type {PolyCoordType} */\n      this.sketchCoords_[0];\n\n      if (coordinates.length >= this.maxPoints_) {\n        if (this.freehand_) {\n          coordinates.pop();\n        } else {\n          done = true;\n        }\n      }\n\n      coordinates.push(coordinate.slice());\n\n      if (done) {\n        this.finishCoordinate_ = coordinates[0];\n      }\n\n      this.geometryFunction_(this.sketchCoords_, geometry);\n    }\n\n    this.updateSketchFeatures_();\n\n    if (done) {\n      this.finishDrawing();\n    }\n  };\n  /**\n   * Remove last point of the feature currently being drawn.\n   * @api\n   */\n\n\n  Draw.prototype.removeLastPoint = function () {\n    if (!this.sketchFeature_) {\n      return;\n    }\n\n    var geometry = this.sketchFeature_.getGeometry();\n    var coordinates;\n    /** @type {LineString} */\n\n    var sketchLineGeom;\n\n    if (this.mode_ === Mode.LINE_STRING) {\n      coordinates =\n      /** @type {LineCoordType} */\n      this.sketchCoords_;\n      coordinates.splice(-2, 1);\n      this.geometryFunction_(coordinates, geometry);\n\n      if (coordinates.length >= 2) {\n        this.finishCoordinate_ = coordinates[coordinates.length - 2].slice();\n      }\n    } else if (this.mode_ === Mode.POLYGON) {\n      coordinates =\n      /** @type {PolyCoordType} */\n      this.sketchCoords_[0];\n      coordinates.splice(-2, 1);\n      sketchLineGeom = this.sketchLine_.getGeometry();\n      sketchLineGeom.setCoordinates(coordinates);\n      this.geometryFunction_(this.sketchCoords_, geometry);\n    }\n\n    if (coordinates.length === 0) {\n      this.finishCoordinate_ = null;\n    }\n\n    this.updateSketchFeatures_();\n  };\n  /**\n   * Stop drawing and add the sketch feature to the target layer.\n   * The {@link module:ol/interaction/Draw~DrawEventType.DRAWEND} event is\n   * dispatched before inserting the feature.\n   * @api\n   */\n\n\n  Draw.prototype.finishDrawing = function () {\n    var sketchFeature = this.abortDrawing_();\n\n    if (!sketchFeature) {\n      return;\n    }\n\n    var coordinates = this.sketchCoords_;\n    var geometry = sketchFeature.getGeometry();\n\n    if (this.mode_ === Mode.LINE_STRING) {\n      // remove the redundant last point\n      coordinates.pop();\n      this.geometryFunction_(coordinates, geometry);\n    } else if (this.mode_ === Mode.POLYGON) {\n      // remove the redundant last point in ring\n\n      /** @type {PolyCoordType} */\n      coordinates[0].pop();\n      this.geometryFunction_(coordinates, geometry);\n      coordinates = geometry.getCoordinates();\n    } // cast multi-part geometries\n\n\n    if (this.type_ === _GeometryType.default.MULTI_POINT) {\n      sketchFeature.setGeometry(new _MultiPoint.default([\n      /** @type {PointCoordType} */\n      coordinates]));\n    } else if (this.type_ === _GeometryType.default.MULTI_LINE_STRING) {\n      sketchFeature.setGeometry(new _MultiLineString.default([\n      /** @type {LineCoordType} */\n      coordinates]));\n    } else if (this.type_ === _GeometryType.default.MULTI_POLYGON) {\n      sketchFeature.setGeometry(new _MultiPolygon.default([\n      /** @type {PolyCoordType} */\n      coordinates]));\n    } // First dispatch event to allow full set up of feature\n\n\n    this.dispatchEvent(new DrawEvent(DrawEventType.DRAWEND, sketchFeature)); // Then insert feature\n\n    if (this.features_) {\n      this.features_.push(sketchFeature);\n    }\n\n    if (this.source_) {\n      this.source_.addFeature(sketchFeature);\n    }\n  };\n  /**\n   * Stop drawing without adding the sketch feature to the target layer.\n   * @return {Feature} The sketch feature (or null if none).\n   * @private\n   */\n\n\n  Draw.prototype.abortDrawing_ = function () {\n    this.finishCoordinate_ = null;\n    var sketchFeature = this.sketchFeature_;\n\n    if (sketchFeature) {\n      this.sketchFeature_ = null;\n      this.sketchPoint_ = null;\n      this.sketchLine_ = null;\n      this.overlay_.getSource().clear(true);\n    }\n\n    return sketchFeature;\n  };\n  /**\n   * Extend an existing geometry by adding additional points. This only works\n   * on features with `LineString` geometries, where the interaction will\n   * extend lines by adding points to the end of the coordinates array.\n   * @param {!Feature<LineString>} feature Feature to be extended.\n   * @api\n   */\n\n\n  Draw.prototype.extend = function (feature) {\n    var geometry = feature.getGeometry();\n    var lineString = geometry;\n    this.sketchFeature_ = feature;\n    this.sketchCoords_ = lineString.getCoordinates();\n    var last = this.sketchCoords_[this.sketchCoords_.length - 1];\n    this.finishCoordinate_ = last.slice();\n    this.sketchCoords_.push(last.slice());\n    this.updateSketchFeatures_();\n    this.dispatchEvent(new DrawEvent(DrawEventType.DRAWSTART, this.sketchFeature_));\n  };\n  /**\n   * Redraw the sketch features.\n   * @private\n   */\n\n\n  Draw.prototype.updateSketchFeatures_ = function () {\n    var sketchFeatures = [];\n\n    if (this.sketchFeature_) {\n      sketchFeatures.push(this.sketchFeature_);\n    }\n\n    if (this.sketchLine_) {\n      sketchFeatures.push(this.sketchLine_);\n    }\n\n    if (this.sketchPoint_) {\n      sketchFeatures.push(this.sketchPoint_);\n    }\n\n    var overlaySource = this.overlay_.getSource();\n    overlaySource.clear(true);\n    overlaySource.addFeatures(sketchFeatures);\n  };\n  /**\n   * @private\n   */\n\n\n  Draw.prototype.updateState_ = function () {\n    var map = this.getMap();\n    var active = this.getActive();\n\n    if (!map || !active) {\n      this.abortDrawing_();\n    }\n\n    this.overlay_.setMap(active ? map : null);\n  };\n\n  return Draw;\n}(_Pointer.default);\n/**\n * @return {import(\"../style/Style.js\").StyleFunction} Styles.\n */\n\n\nfunction getDefaultStyleFunction() {\n  var styles = (0, _Style.createEditingStyle)();\n  return function (feature, resolution) {\n    return styles[feature.getGeometry().getType()];\n  };\n}\n/**\n * Create a `geometryFunction` for `type: 'Circle'` that will create a regular\n * polygon with a user specified number of sides and start angle instead of an\n * `import(\"../geom/Circle.js\").Circle` geometry.\n * @param {number=} opt_sides Number of sides of the regular polygon. Default is\n *     32.\n * @param {number=} opt_angle Angle of the first point in radians. 0 means East.\n *     Default is the angle defined by the heading from the center of the\n *     regular polygon to the current pointer position.\n * @return {GeometryFunction} Function that draws a\n *     polygon.\n * @api\n */\n\n\nfunction createRegularPolygon(opt_sides, opt_angle) {\n  return function (coordinates, opt_geometry) {\n    var center =\n    /** @type {LineCoordType} */\n    coordinates[0];\n    var end =\n    /** @type {LineCoordType} */\n    coordinates[1];\n    var radius = Math.sqrt((0, _coordinate.squaredDistance)(center, end));\n    var geometry = opt_geometry ?\n    /** @type {Polygon} */\n    opt_geometry : (0, _Polygon.fromCircle)(new _Circle.default(center), opt_sides);\n    var angle = opt_angle;\n\n    if (!opt_angle) {\n      var x = end[0] - center[0];\n      var y = end[1] - center[1];\n      angle = Math.atan(y / x) - (x < 0 ? Math.PI : 0);\n    }\n\n    (0, _Polygon.makeRegular)(geometry, center, radius, angle);\n    return geometry;\n  };\n}\n/**\n * Create a `geometryFunction` that will create a box-shaped polygon (aligned\n * with the coordinate system axes).  Use this with the draw interaction and\n * `type: 'Circle'` to return a box instead of a circle geometry.\n * @return {GeometryFunction} Function that draws a box-shaped polygon.\n * @api\n */\n\n\nfunction createBox() {\n  return function (coordinates, opt_geometry) {\n    var extent = (0, _extent.boundingExtent)(\n    /** @type {LineCoordType} */\n    coordinates);\n    var boxCoordinates = [[(0, _extent.getBottomLeft)(extent), (0, _extent.getBottomRight)(extent), (0, _extent.getTopRight)(extent), (0, _extent.getTopLeft)(extent), (0, _extent.getBottomLeft)(extent)]];\n    var geometry = opt_geometry;\n\n    if (geometry) {\n      geometry.setCoordinates(boxCoordinates);\n    } else {\n      geometry = new _Polygon.default(boxCoordinates);\n    }\n\n    return geometry;\n  };\n}\n/**\n * Get the drawing mode.  The mode for mult-part geometries is the same as for\n * their single-part cousins.\n * @param {GeometryType} type Geometry type.\n * @return {Mode} Drawing mode.\n */\n\n\nfunction getMode(type) {\n  var mode;\n\n  if (type === _GeometryType.default.POINT || type === _GeometryType.default.MULTI_POINT) {\n    mode = Mode.POINT;\n  } else if (type === _GeometryType.default.LINE_STRING || type === _GeometryType.default.MULTI_LINE_STRING) {\n    mode = Mode.LINE_STRING;\n  } else if (type === _GeometryType.default.POLYGON || type === _GeometryType.default.MULTI_POLYGON) {\n    mode = Mode.POLYGON;\n  } else if (type === _GeometryType.default.CIRCLE) {\n    mode = Mode.CIRCLE;\n  }\n\n  return (\n    /** @type {!Mode} */\n    mode\n  );\n}\n\nvar _default = Draw;\nexports.default = _default;"},"sourceMaps":null,"error":null,"hash":"83a186344e977b3a44424661bdd08903","cacheData":{"env":{}}}